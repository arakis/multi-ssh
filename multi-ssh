#!/bin/bash

# This script creates a local tmux session and connects to remote servers from a config file.
# For each server, it establishes an SSH connection and creates or attaches to a remote tmux session.
# If the script is run multiple times, it destroys any existing local session and creates a new one.

# Function to display help message
display_help() {
    echo "Usage: multi-ssh [OPTIONS]"
    echo
    echo "Creates a local tmux session and connects to remote servers listed in the config file."
    echo "By default, creates a single window with one pane per server."
    echo "For each server, it establishes an SSH connection and creates or attaches to a tmux session."
    echo
    echo "Options:"
    echo "  --help                     Displays this help message and exits"
    echo "  completion                 Returns the completion source file"
    echo
    echo "  Main Commands:"
    echo "  send-keys [command]        Sends keys to each remote session without executing"
    echo "  exec [command]             Executes the specified command on each remote session"
    echo "  kill                       Kill remote tmux sessions and exit"
    echo "  copy [remote:|]:path [remote:|]:path   Copy files between local and remote using rsync"
    echo "  toggle-layout              (Internal) Toggles between pane and window layout in an active session"
    echo
    echo "  Layout & Session Options:"
    echo "  --layout <pane|window>     Specify layout: 'pane' (default, one window, multiple panes) or 'window' (one window per server)"
    echo "  --syncronize-panes         Enable synchronized input across panes (only valid with '--layout pane')"
    echo "  --session <name>           Set both local and remote session name (overridden by specific session options)"
    echo "  --local-session <name>     Specify local tmux session name (default: multi-ssh)"
    echo "  --remote-session <name>    Specify remote tmux session name (default: remote-session)"
    echo
    echo "  Connection Options:"
    echo "  --remote-user <username>   Switch to this user after connecting"
    echo "  --ssh-user <username>      SSH login username"
    echo "  --ssh-key <keyfile>        Path to private key file for SSH"
    echo "  --config <path>            Path to servers configuration file (default: ./servers.conf)"
    echo "  --servers <host1,...>      Comma-separated list of servers to use (filters servers.conf)"
    echo "  --initial-workdir <path>   Change to this directory on remote hosts before starting tmux"
    echo
    echo "In pane layout mode, use 'Prefix + S' (e.g., Ctrl+B then Shift+S) to toggle pane synchronization on/off."
    echo "Use 'Prefix + L' to attempt toggling between pane and window layouts (experimental)."
    echo
    echo "If no command is specified with send-keys or exec, commands from the config file's [servers] section will be used."
    echo
    echo "Configuration file format (e.g., servers.conf):"
    echo "  [servers]"
    echo "  # List servers, one per line. Optionally add a default command."
    echo "  server1.example.com"
    echo "  server2.example.com ls -la /var/log"
    echo "  192.168.1.10 htop"
    echo
    echo "  [options]"
    echo "  # Set default options (command-line flags override these)"
    echo "  # Options correspond to long command-line flags without '--'"
    echo "  # Example:"
    echo "  # local-session = my-session"
    echo "  # remote-session = remote-tmux"
    echo "  # remote-user = appuser"
    echo "  # ssh-user = admin"
    echo "  # ssh-key = ~/.ssh/id_rsa_admin"
    echo "  # synchronize-panes = true"
    echo "  # layout = window"
    echo "  # initial-workdir = /var/www/project"
    echo
    echo "  [include]"
    echo "  # Include other configuration files. Paths can be absolute or relative"
    echo "  # to the current file's location. Included files are parsed recursively."
    echo "  # Cycle detection prevents infinite loops."
    echo "  # Example:"
    echo "  # /path/to/global.conf"
    echo "  # ../shared/common-servers.conf"
    echo "  # ./project-specific.conf"
    echo
    echo "  Lines starting with # or ; are treated as comments and ignored."
    echo "  Empty lines are also ignored."
    echo
    echo "Examples:"
    echo "  multi-ssh                                   # Connect to all servers using servers.conf"
    echo "  multi-ssh --config ~/my-servers.conf         # Use a custom servers configuration file"
    echo "  multi-ssh --syncronize-panes                # Connect with synchronized panes"
    echo "  multi-ssh exec 'ls -la'                   # Connect and run 'ls -la' on all servers"
    echo "  multi-ssh kill                            # Kill all remote tmux sessions"
    echo "  multi-ssh copy ~/file.txt remote:~/file.txt  # Upload file to all servers"
    echo "  multi-ssh copy remote:/var/log/app.log ./logs/  # Download file from all servers"
    exit 0
}

# Default session names
LOCAL_SESSION_NAME=""
REMOTE_SESSION_NAME=""
SESSION_NAME="" # Set via --session, overrides specific local/remote names

# Default remote user to switch to after connecting
REMOTE_USER=""

# Default SSH connection options
SSH_USER=""
SSH_KEY=""
INITIAL_WORKDIR="" # Initial remote working directory before starting tmux

# Default config file path
CONFIG_FILE="./servers.conf"

# Default options
SYNCHRONIZE_PANES=false
LAYOUT_MODE="pane" # Layout mode: 'pane' (default) or 'window'
SEND_KEYS_COMMAND=""
USE_SERVER_COMMAND=false
EXECUTE_COMMAND=false
KILL_MODE=false      # If true, kill remote sessions instead of connecting
COPY_MODE=false      # If true, copy files using rsync instead of connecting
TOGGLE_LAYOUT_MODE=false # If true, toggle layout of existing session
SRC_PATH=""
DEST_PATH=""
FILTER_SERVERS_LIST="" # Comma-separated list from --servers to filter config

# Arrays to hold server addresses and their specific commands
declare -a servers=()
declare -a server_commands=()
# Temporary arrays to store initial config data before filtering
declare -a config_servers=()
declare -a config_server_commands=()

# New: Keep track of parsed config files to prevent infinite loops
declare -A PARSED_CONFIG_FILES

# Function to parse INI configuration file
parse_ini_config() {
    local config_file="$1"
    local config_dir
    config_dir=$(dirname "$config_file") # Directory of the current config file

    # Resolve the real path to prevent duplicates/loops with symlinks etc.
    local abs_config_path
    if [[ ! -f "$config_file" ]]; then
        echo "Warning: Config file '$config_file' not found." >&2
        return 1
    fi
    # Attempt to get the real path; handle potential errors if realpath isn't available or fails
    abs_config_path=$(realpath "$config_file" 2>/dev/null)
    if [[ $? -ne 0 || -z "$abs_config_path" ]]; then
        # Fallback if realpath fails or isn't installed
        # For basic relative paths within the same dir structure, this might suffice
        if [[ "$config_file" == /* ]]; then
            abs_config_path="$config_file"
        else
            # This is a simplistic approach for relative paths if realpath failed
             abs_config_path="$PWD/$config_file"
             # Basic normalization attempt: remove trailing /. and handle simple ..
             abs_config_path=$(echo "$abs_config_path" | sed -e 's#/\./#/#g' -e 's#/[^/]\+/\.\./#/#g')

        fi
         echo "Warning: Could not resolve absolute path for '$config_file' using realpath. Using simplified path '$abs_config_path'. Cycle detection might be less reliable." >&2
    fi


    # Check for circular dependencies
    if [[ -v PARSED_CONFIG_FILES["$abs_config_path"] ]]; then
        echo "Warning: Skipping already parsed or currently parsing config file '$config_file' (path: $abs_config_path) to prevent circular dependency." >&2
        return 0
    fi
    # Mark this file as being parsed
    PARSED_CONFIG_FILES["$abs_config_path"]=1


    echo "Parsing config file: $config_file" >&2 # Added for debugging includes

    # Start assuming the implicit [servers] section
    local current_section="servers"
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Trim leading/trailing whitespace
        line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

        # Skip empty lines and comments (lines starting with # or ;)
        if [[ -z "$line" || "$line" =~ ^[#\;] ]]; then
            continue
        fi

        # Check for section header
        if [[ "$line" =~ ^\[(.*)\]$ ]]; then
            current_section="${BASH_REMATCH[1]}"
            # Convert to lowercase for case-insensitive matching
            current_section=$(echo "$current_section" | tr '[:upper:]' '[:lower:]')
            continue
        fi

        # Process lines based on section
        case "$current_section" in
            servers)
                # Extract server and command
                local server=$(echo "$line" | awk '{print $1}')
                local command=$(echo "$line" | awk '{$1=""; print $0}' | sed 's/^[ \t]*//') # Get rest of line
                if [[ -n "$server" ]]; then
                    # Store in temporary config arrays first
                    config_servers+=("$server")
                    config_server_commands+=("$command")
                fi
                ;;
            options)
                # Process key-value pairs
                if [[ "$line" =~ ^([^=[:space:]]+)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
                    local key="${BASH_REMATCH[1]}"
                    local value="${BASH_REMATCH[2]}"
                    # Trim potential quotes from value
                    value=$(echo "$value" | sed -e "s/^'//" -e "s/'$//" -e 's/^"//' -e 's/"$//')

                    # Set global variables based on key (these might be overridden by CLI args later)
                    case "$key" in
                        local-session) LOCAL_SESSION_NAME="$value" ;;
                        remote-session) REMOTE_SESSION_NAME="$value" ;;
                        remote-user) REMOTE_USER="$value" ;;
                        ssh-user) SSH_USER="$value" ;;
                        ssh-key) SSH_KEY="$value" ;;
                        synchronize-panes)
                            if [[ "$value" == "true" || "$value" == "yes" || "$value" == "1" ]]; then
                                SYNCHRONIZE_PANES=true
                            elif [[ "$value" == "false" || "$value" == "no" || "$value" == "0" ]]; then
                                SYNCHRONIZE_PANES=false
                            else
                                echo "Warning: Invalid boolean value '$value' for synchronize-panes in config file. Ignoring." >&2
                            fi
                            ;;
                        layout) # Handle layout option from config
                            if [[ "$value" == "pane" || "$value" == "window" ]]; then
                                LAYOUT_MODE="$value"
                            else
                                echo "Warning: Invalid value '$value' for layout in config file. Must be 'pane' or 'window'. Ignoring." >&2
                            fi
                            ;;
                        initial-workdir) INITIAL_WORKDIR="$value" ;;
                        *) echo "Warning: Unknown option '$key' in [options] section of config file." >&2 ;;
                    esac
                else
                     echo "Warning: Malformed line in [options] section: '$line'" >&2
                fi
                ;;
            include) # New section handler
                # The line itself is the path to the file to include
                local include_path="$line"
                local resolved_include_path

                # Resolve the path: absolute or relative to the current config file's directory
                if [[ "$include_path" == /* ]]; then
                    resolved_include_path="$include_path" # Absolute path
                else
                    resolved_include_path="$config_dir/$include_path" # Relative path
                fi

                # Recursively parse the included file
                # The recursive call will handle its own path resolution and cycle detection
                parse_ini_config "$resolved_include_path"
                ;;
            *)
                # Handle unknown sections if needed, or ignore
                # echo "Warning: Unknown section '$current_section' in config file '$config_file'." >&2
                ;;
        esac
    done < "$config_file"

    return 0
}

# Handle the completion option
if [[ "$1" == "completion" ]]; then
    # Output the completion script content directly
    cat <<'EOF'
#!/bin/bash

_multi_ssh_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    
    # Group options in a more meaningful order
    # Help and info options, main commands, session options, connection options
    opts="--help --syncronize-panes kill copy send-keys exec --session --local-session --remote-session --remote-user --ssh-user --ssh-key --config --servers --layout --initial-workdir completion"

    # Check if we're completing a copy operation anywhere in the command
    local i
    local copy_mode=0
    for ((i=1; i<COMP_CWORD; i++)); do
        if [[ "${COMP_WORDS[i]}" == "copy" ]]; then
            copy_mode=1
            break
        fi
    done

    # Handle all cases
    if [[ $copy_mode -eq 1 && $COMP_CWORD -gt $((i+1)) ]]; then
        # We're completing the second part (destination) of a copy operation
        if [[ ${cur} == *:* ]]; then
            # Split at the colon
            local remote_part="${cur%%:*}"
            local local_part="${cur#*:}"
            
            # Complete the local part but preserve the remote part
            local completions=($(compgen -f -- "${local_part}"))
            COMPREPLY=()
            for comp in "${completions[@]}"; do
                COMPREPLY+=("${remote_part}:${comp}")
            done
        else
            # Add "remote:" as a completion option along with standard file completion
            local completions=($(compgen -f -- "${cur}"))
            
            # Only add remote: as an option if it matches the current prefix
            if [[ "remote:" =~ ^"${cur}" ]]; then
                completions+=("remote:")
            fi
            
            COMPREPLY=("${completions[@]}")
        fi
        return 0
    fi

    # First check if we're at the start of the command (first argument after multi-ssh)
    if [[ $COMP_CWORD -eq 1 ]]; then
        # We're at the first argument, suggest all available options
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi

    # Handle completion for options that take arguments
    case "$prev" in
        --local-session|--remote-session|--remote-user|--ssh-user)
            # No specific suggestions, default completion (e.g., usernames) might apply
            return 0
            ;;
        --ssh-key|--config|--initial-workdir)
            # Suggest files/directories
            COMPREPLY=( $(compgen -f -- ${cur}) )
            return 0
            ;;
        --servers)
            # No specific suggestions for server list
            return 0
            ;;
        --layout)
            # Suggest layout modes
            COMPREPLY=($(compgen -W "pane window" -- ${cur}))
            return 0
            ;;
        send-keys|exec)
            # No specific suggestions for commands
            return 0
            ;;
        copy)
             # Suggest files/directories or "remote:" for the first copy argument
            if [[ "remote:" == "${cur}"* ]]; then
                 COMPREPLY=($(compgen -f -P "remote:" -- ${cur#remote:}) $(compgen -f -- ${cur}) "remote:")
            else
                 COMPREPLY=($(compgen -f -- ${cur}) "remote:")
            fi

            if [[ "remote:" == "${cur}"* ]] && ! [[ " ${COMPREPLY[@]} " =~ " remote: " ]]; then
                 COMPREPLY+=("remote:")
            fi
            return 0
            ;;
    esac

    # If the previous word was not an option that takes an argument,
    # suggest options or main commands.
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
    else
        # Suggest main commands if not starting with '-' (completion is usually first)
        local commands="send-keys exec kill copy"
        COMPREPLY=($(compgen -W "${commands}" -- ${cur}))
    fi

    return 0
}

complete -F _multi_ssh_completion multi-ssh
EOF
    exit 0
fi

# Display help if requested
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    display_help
fi

# Determine config file path *before* parsing other arguments
# This allows --config to be processed correctly if it appears early
temp_config_file="$CONFIG_FILE" # Use default initially
i=1
args=("$@")
while [[ $i -le $# ]]; do
    if [[ "${args[$((i-1))]}" == "--config" && -n "${args[$i]}" ]]; then
        temp_config_file="${args[$i]}"
        # Remove --config and its value from args for later parsing
        unset args[$((i-1))]
        unset args[$i]
        args=("${args[@]}") # Re-index array
        set -- "${args[@]}" # Reset positional parameters
        break # Found config, stop searching
    fi
    ((i++))
done
CONFIG_FILE="$temp_config_file"

# Parse the INI configuration file *first*
# Settings here act as new defaults, potentially overridden by CLI args
parse_ini_config "$CONFIG_FILE"

# Parse command line arguments (these override config file settings)
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            # Already handled, but keep for completeness or if order changes
            display_help
            ;;
        --syncronize-panes)
            SYNCHRONIZE_PANES=true # CLI overrides config
            shift
            ;;
        kill)
            KILL_MODE=true
            shift
            ;;
        toggle-layout) # New case
            TOGGLE_LAYOUT_MODE=true
            shift
            ;;
        copy)
            COPY_MODE=true
            if [[ -n "$2" && -n "$3" && ! "$2" =~ ^--* && ! "$3" =~ ^--* ]]; then
                SRC_PATH="$2"
                DEST_PATH="$3"
                shift 3
            else
                echo "Error: copy requires both source and destination path arguments"
                echo "Usage: copy [remote:|]:source_path [remote:|]:destination_path"
                exit 1
            fi
            ;;
        send-keys|exec)
            if [[ "$1" == "exec" ]]; then
                EXECUTE_COMMAND=true
            fi
            # Check if the next argument is a command and not another option
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SEND_KEYS_COMMAND="$2" # CLI overrides config/default behavior
                USE_SERVER_COMMAND=false # Explicit command given, don't use server-specific ones
                shift 2
            else
                # No command provided with send-keys/exec, use server-specific ones from config
                USE_SERVER_COMMAND=true
                shift 1
            fi
            ;;
        --session)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SESSION_NAME="$2" # Store the session name
                shift 2
            else
                echo "Error: --session requires a name argument" >&2
                exit 1
            fi
            ;;
        --local-session)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                LOCAL_SESSION_NAME="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --local-session requires a name argument" >&2
                exit 1
            fi
            ;;
        --remote-session)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                REMOTE_SESSION_NAME="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --remote-session requires a name argument" >&2
                exit 1
            fi
            ;;
        --remote-user)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                REMOTE_USER="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --remote-user requires a username argument" >&2
                exit 1
            fi
            ;;
        --ssh-user)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SSH_USER="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --ssh-user requires a username argument" >&2
                exit 1
            fi
            ;;
        --ssh-key)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SSH_KEY="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --ssh-key requires a keyfile path argument" >&2
                exit 1
            fi
            ;;
        --config)
            # Already handled, just shift past the value if it remained somehow
             if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                shift 2
             else
                # Should have been handled, but error if value missing
                echo "Error: --config requires a path argument" >&2
                exit 1
             fi
            ;;
        --servers)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                FILTER_SERVERS_LIST="$2" # Store the comma-separated list
                shift 2
            else
                echo "Error: --servers requires a comma-separated list of servers" >&2
                exit 1
            fi
            ;;
        --layout) # Handle layout option from CLI
            if [[ "$2" == "pane" || "$2" == "window" ]]; then
                LAYOUT_MODE="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --layout requires 'pane' or 'window' argument" >&2
                exit 1
            fi
            ;;
        --initial-workdir) # New case
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                INITIAL_WORKDIR="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --initial-workdir requires a path argument" >&2
                exit 1
            fi
            ;;
        *)
            # If it's not a known option or command, it might be an implicit command for send-keys/exec
            # Or just an error. Let's assume error for now unless send-keys/exec was the *last* arg.
            # This part is tricky. The current logic handles send-keys/exec [cmd] correctly.
            # If we reach here, it's likely an unknown option.
            echo "Error: Unknown option or misplaced argument: $1" >&2
            display_help # Show help on error
            ;;
    esac
done

# Apply the --session value after all options are parsed
# Only set the session names if they weren't explicitly specified
if [[ -n "$SESSION_NAME" ]]; then
    # Set the local session name if not explicitly set
    if [[ -z "$LOCAL_SESSION_NAME" ]]; then
        LOCAL_SESSION_NAME="$SESSION_NAME"
    fi
    
    # Set the remote session name if not explicitly set
    if [[ -z "$REMOTE_SESSION_NAME" ]]; then
        REMOTE_SESSION_NAME="$SESSION_NAME"
    fi
fi

# After applying --session, set defaults if still not set
if [[ -z "$LOCAL_SESSION_NAME" ]]; then
    LOCAL_SESSION_NAME="multi-ssh"
fi

if [[ -z "$REMOTE_SESSION_NAME" ]]; then
    REMOTE_SESSION_NAME="remote-session"
fi

# --- Validation ---
# Check for incompatible options
if [[ "$LAYOUT_MODE" == "window" && "$SYNCHRONIZE_PANES" = true ]]; then
    echo "Error: --syncronize-panes cannot be used with --layout window." >&2
    exit 1
fi

# --- Filter servers based on --servers option ---
if [[ -n "$FILTER_SERVERS_LIST" ]]; then
    echo "Filtering servers based on --servers option: $FILTER_SERVERS_LIST"
    declare -a requested_servers=()
    # Split the comma-separated list into an array
    IFS=',' read -ra requested_servers <<< "$FILTER_SERVERS_LIST"

    # Create a map for quick lookup of config servers and their commands
    declare -A config_server_map
    for i in "${!config_servers[@]}"; do
        config_server_map["${config_servers[$i]}"]="${config_server_commands[$i]}"
    done

    # Clear the final server arrays and rebuild based on the requested list
    servers=()
    server_commands=()

    for req_server in "${requested_servers[@]}"; do
        # Trim whitespace just in case
        req_server=$(echo "$req_server" | xargs)
        if [[ -v config_server_map["$req_server"] ]]; then
            # Server found in config, use it and its command
            servers+=("$req_server")
            server_commands+=("${config_server_map["$req_server"]}")
            echo "  -> Including '$req_server' (found in config)"
        else
            # Server not found in config, include it without a command
            servers+=("$req_server")
            server_commands+=("")
            echo "  -> Including '$req_server' (not found in config)"
        fi
    done
else
    # No --servers filter, use all servers from the config file
    servers=("${config_servers[@]}")
    server_commands=("${config_server_commands[@]}")
fi
# --- End server filtering ---

# Check if servers array is empty (config file not found or empty [servers] section, or filter resulted in empty list)
if [ ${#servers[@]} -eq 0 ]; then
    # Adjust error message slightly to account for filtering
    if [[ -n "$FILTER_SERVERS_LIST" ]]; then
        echo "Error: No servers matched the filter criteria from '$CONFIG_FILE'." >&2
    elif [ ! -f "$CONFIG_FILE" ]; then
         echo "Error: Configuration file '$CONFIG_FILE' not found." >&2
    else
         echo "Error: No servers defined in the [servers] section of '$CONFIG_FILE'." >&2
    fi
    # Allow kill and copy modes to proceed even if the list is empty now,
    # they might have specific logic or warnings later.
    if [ "$COPY_MODE" = false ] && [ "$KILL_MODE" = false ]; then
        exit 1
    fi
fi

# Helper functions for copy mode (and now kill mode)
setup_ssh_options() {
    local ssh_opts="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
    if [ -n "$SSH_KEY" ]; then
        ssh_opts="$ssh_opts -i $SSH_KEY"
    fi
    echo "$ssh_opts"
}

get_server_address() {
    local server="$1"
    local server_addr="$server"
    if [ -n "$SSH_USER" ]; then
        server_addr="$SSH_USER@$server"
    fi
    echo "$server_addr"
}

# Process remote paths, replacing ~ with the user's home directory
process_remote_path() {
    local path="$1"
    # If remote user is specified, replace ~ with /home/username in remote path
    if [ -n "$REMOTE_USER" ]; then
        # Replace any occurrence of ~/ with the remote user's home directory
        path="${path//\~\//\/home\/$REMOTE_USER\/}"
        # Also handle standalone ~ (without trailing slash)
        path="${path//\~/\/home\/$REMOTE_USER}"
    fi
    echo "$path"
}

# Build the rsync command with appropriate options
build_rsync_command() {
    local src="$1"
    local dest="$2"
    local ssh_opts="$3"
    
    local rsync_cmd="rsync -avz -e 'ssh $ssh_opts'"
    
    # Add remote user sudo if specified
    if [ -n "$REMOTE_USER" ]; then
        rsync_cmd="$rsync_cmd --rsync-path=\"sudo -u $REMOTE_USER rsync\""
    fi
    
    # Complete the command with source and destination
    rsync_cmd="$rsync_cmd \"$src\" \"$dest\""
    
    echo "$rsync_cmd"
}

# Function to toggle layout between pane and window mode
toggle_layout() {
    local session_name="$1"
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        echo "Error: Session '$session_name' not found." >&2
        exit 1
    fi

    local num_windows=$(tmux list-windows -t "$session_name" -F '#I' | wc -l)
    local num_panes_win0=$(tmux list-panes -t "$session_name:0" -F '#P' | wc -l)

    if [[ $num_windows -gt 1 && $num_panes_win0 -eq 1 ]]; then
        # --- Current layout is WINDOW, switch to PANE ---
        # Get list of window indices, excluding window 0
        local window_indices=$(tmux list-windows -t "$session_name" -F '#I' | grep -v '^0$')

        for w_idx in $window_indices; do
            local source_pane="$session_name:$w_idx.0" # Assume pane 0 in other windows
            local target_window="$session_name:0"
            # Join the pane into window 0. -d keeps the source pane's window from being selected.
            # The source window should be killed automatically if empty after join.
            tmux join-pane -s "$source_pane" -t "$target_window" -d
            if [ $? -ne 0 ]; then
                 echo "Warning: Failed to join pane from window $w_idx." >&2
            fi
        done
        # Apply tiled layout to window 0
        tmux select-layout -t "$session_name:0" tiled
        # Optional: Store state
        # tmux set-option -g -t "$session_name" @multi_ssh_layout "pane"

        # Explicitly select the first pane in the main window
        tmux select-window -t "$session_name:0"
        tmux select-pane -t "$session_name:0.0"

    elif [[ $num_windows -eq 1 && $num_panes_win0 -gt 1 ]]; then
        # --- Current layout is PANE, switch to WINDOW ---
        # Get list of pane indices in window 0, excluding pane 0
        # Iterate in reverse order to avoid index shifting issues
        local pane_indices=$(tmux list-panes -t "$session_name:0" -F '#P' | sort -nr | grep -v '^0$')

        for p_idx in $pane_indices; do
            local source_pane="$session_name:0.$p_idx"
            # Retrieve the server name stored in the pane's options
            local server_name=$(tmux show-options -t "$source_pane" -qv @multi_ssh_server_name)
            if [ -z "$server_name" ]; then
                # Fallback name if option wasn't set or retrieved
                server_name="server-win-$p_idx"
                echo "Warning: Could not retrieve server name for pane $p_idx. Using fallback name '$server_name'."
            fi
            # Break the pane into a new window named after the server. -d keeps focus.
            tmux break-pane -s "$source_pane" -n "$server_name" -d
             if [ $? -ne 0 ]; then
                 echo "Warning: Failed to break pane $p_idx." >&2
             fi
        done
         # Optional: Store state
         # tmux set-option -g -t "$session_name" @multi_ssh_layout "window"

        # Explicitly select the first pane in the main window (which remains after breaking)
        tmux select-window -t "$session_name:0"
        tmux select-pane -t "$session_name:0.0"

    else
        echo "Error: Current layout is ambiguous or unsupported for toggling." >&2
        echo "Expected either multiple windows with 1 pane each, or 1 window with multiple panes." >&2
        exit 1
    fi

    exit 0
}

# New function to handle killing remote sessions directly
kill_remote_sessions() {
    echo "Attempting to kill remote tmux session '$REMOTE_SESSION_NAME' on all servers..."

    for i in $(seq 0 $((${#servers[@]}-1))); do
        local server=${servers[$i]}
        local ssh_opts=$(setup_ssh_options)
        local server_addr=$(get_server_address "$server")

        # Construct the remote command
        local kill_cmd="tmux kill-session -t $REMOTE_SESSION_NAME"
        if [ -n "$REMOTE_USER" ]; then
            # If remote user is specified, run the kill command as that user via sudo
            # Ensure sudo doesn't require a tty (-n) and runs in the background briefly (-b) if needed,
            # though for kill-session, direct execution should be fine.
            # Using direct command execution is generally preferred over complex sudo options.
            kill_cmd="sudo -u $REMOTE_USER $kill_cmd"
        fi

        # Add error suppression for cases where the session doesn't exist
        kill_cmd="$kill_cmd 2>/dev/null || true" # Suppress errors if session doesn't exist, continue script

        echo "Executing on $server: ssh $ssh_opts $server_addr \"$kill_cmd\""

        # Execute the kill command via a non-interactive SSH session
        ssh $ssh_opts $server_addr "$kill_cmd"

        if [ $? -eq 0 ]; then
            # Note: This only checks SSH connection success, not necessarily tmux kill success.
            # Check SSH connection status (tmux kill success ignored due to '|| true')
            echo "Kill command sent to $server."
        else
            echo "Error sending kill command to $server."
        fi
        echo "------------------------"
    done

    echo "Finished sending kill commands to all servers."
    # Optionally, kill the local session if it somehow exists (though it shouldn't be created in kill mode)
    # Kill potentially lingering local session
    if tmux has-session -t $LOCAL_SESSION_NAME 2>/dev/null; then
        echo "Killing potentially existing local session: $LOCAL_SESSION_NAME"
        tmux kill-session -t $LOCAL_SESSION_NAME
    fi
    exit 0
}

# --- Execute Kill Mode ---
# If in kill mode, execute the dedicated function and exit immediately.
# Execute kill logic *before* creating the local session.
if [ "$KILL_MODE" = true ]; then
    # Check server list *after* potential filtering
    if [ ${#servers[@]} -eq 0 ]; then
        echo "Warning: Server list is empty (due to config or --servers filter). Kill command cannot be sent."
        exit 1
    fi
    kill_remote_sessions # Call the new function
fi

# --- Execute Toggle Layout Mode ---
# If in toggle mode, execute the dedicated function and exit immediately.
# Requires LOCAL_SESSION_NAME to be determined first.
if [ "$TOGGLE_LAYOUT_MODE" = true ]; then
    if [ -z "$LOCAL_SESSION_NAME" ]; then
         echo "Error: Cannot toggle layout without knowing the local session name." >&2
         echo "Please specify --local-session <name> when calling toggle-layout." >&2
         # Note: Guessing session name is too risky.
         exit 1
    fi
    toggle_layout "$LOCAL_SESSION_NAME" # Call the toggle function
    # The toggle_layout function exits on completion or error
fi

# Destroy existing local session if it exists (prevents errors on re-run)
# Do not kill existing session if only toggling layout.
if [ "$TOGGLE_LAYOUT_MODE" = false ]; then
    tmux has-session -t $LOCAL_SESSION_NAME 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "Destroying existing local session: $LOCAL_SESSION_NAME"
        tmux kill-session -t $LOCAL_SESSION_NAME
    fi
fi

# Check if tmux is installed (skip if only using copy mode)
if [ "$COPY_MODE" = false ] && ! command -v tmux &>/dev/null; then
    # Check for tmux binary (unless only copying files).
    echo "Error: tmux is not installed. Please install tmux and try again."
    exit 1
fi

# Check if specified config file exists (This check might be less relevant now if --servers is used without a config)
# Config file existence check (less critical if using --servers without config commands).
if [[ -z "$FILTER_SERVERS_LIST" && ! -f "$CONFIG_FILE" ]]; then
    echo "Error: Configuration file '$CONFIG_FILE' not found and --servers not specified."
    exit 1
fi

# Ensure we have servers to work with (redundant with the check after filtering, but safe)
# Final check for servers after parsing config and applying filters.
if [ ${#servers[@]} -eq 0 ]; then
    # Allow kill/copy modes to proceed, error for normal mode
    if [ "$COPY_MODE" = false ] && [ "$KILL_MODE" = false ]; then
        echo "Error: No servers to connect to (check config file and --servers filter)."
        exit 1
    fi
fi

# If in copy mode, perform the rsync operations and exit
if [ "$COPY_MODE" = true ]; then
    # Check server list *after* potential filtering
    # Ensure servers remain after filtering before attempting copy.
    if [ ${#servers[@]} -eq 0 ]; then
        echo "Warning: Server list is empty (due to config or filter). Copy command will not be executed."
        exit 1 # Or exit 0
    fi
    # Process each server
    for i in $(seq 0 $((${#servers[@]}-1))); do
        server=${servers[$i]}
        ssh_opts=$(setup_ssh_options)
        server_addr=$(get_server_address "$server")
        
        # Determine if we're uploading or downloading
        if [[ "$SRC_PATH" =~ ^remote: ]]; then
            # Downloading: remote to local
            remote_path=$(process_remote_path "${SRC_PATH#remote:}")
            local_path="$DEST_PATH"
            operation="downloading"
            
            # Construct rsync command
            rsync_cmd=$(build_rsync_command "$server_addr:\"$remote_path\"" "$local_path" "$ssh_opts")
            
            # Echo operation info
            echo "Downloading file(s) from $server:$remote_path to $local_path"
            
        else
            # Uploading: local to remote
            local_path="$SRC_PATH"
            remote_path=$(process_remote_path "${DEST_PATH#remote:}")
            operation="uploading"
            
            # Construct rsync command
            rsync_cmd=$(build_rsync_command "$local_path" "$server_addr:\"$remote_path\"" "$ssh_opts")
            
            # Echo operation info
            echo "Uploading file(s) from $local_path to $server:$remote_path"
        fi
        
        # Execute the rsync command
        eval $rsync_cmd
        
        # Check for success
        if [ $? -eq 0 ]; then
            echo "Successfully ${operation} file(s) for server $server"
        else
            echo "Error ${operation} file(s) for server $server"
        fi
        
        echo "------------------------"
    done
    
    # Exit after completing all copy operations
    exit 0
fi

# Create a new local tmux session
tmux new-session -d -s $LOCAL_SESSION_NAME

# Define the remote command to check for existing session and create or attach
remote_cmd="if tmux has-session -t $REMOTE_SESSION_NAME 2>/dev/null; then tmux attach-session -t $REMOTE_SESSION_NAME; else tmux new-session -s $REMOTE_SESSION_NAME; fi"

# Process all servers
for i in $(seq 0 $((${#servers[@]}-1))); do
    server=${servers[$i]}
    server_command=${server_commands[$i]}
    
    if [ $i -eq 0 ]; then
        # For the first server, rename the initial window/pane's window
        tmux rename-window -t $LOCAL_SESSION_NAME:0 "$server"
    else
        # Create new window or pane based on layout mode
        if [ "$LAYOUT_MODE" = "window" ]; then
            # Create a new window for each additional server
            tmux new-window -t $LOCAL_SESSION_NAME: -n "$server"
        else # LAYOUT_MODE is "pane"
            # Create a new pane for each additional server
            tmux split-window -t $LOCAL_SESSION_NAME:0 -v
            # Ensure even layout for all panes
            tmux select-layout -t $LOCAL_SESSION_NAME:0 tiled
        fi
    fi
    
    # Determine target for send-keys based on layout mode
    target=""
    if [ "$LAYOUT_MODE" = "window" ]; then
        # When using windows, we target the window index
        target="$LOCAL_SESSION_NAME:$i"
    else # LAYOUT_MODE is "pane"
        # When using panes, we target the pane index within window 0
        target="$LOCAL_SESSION_NAME:0.$i"
    fi
    
    # Store the server name associated with this target pane/window's main pane
    # Use -p flag for pane-specific option, -w for window option if preferred
    # Let's use pane-specific option for break-pane retrieval
    echo "Setting @multi_ssh_server_name=$server for target $target"
    tmux set-option -t "$target" @multi_ssh_server_name "$server"

    # Disable shell history in the local pane/window
    # Prevent polluting local shell history in the pane.
    tmux send-keys -t "$target" "unset HISTFILE" C-m

    # Build SSH command with optional parameters
    ssh_cmd="ssh -t -o StrictHostKeyChecking=no"
    if [ -n "$SSH_KEY" ]; then
        ssh_cmd="$ssh_cmd -i $SSH_KEY"
    fi
    if [ -n "$SSH_USER" ]; then
        ssh_cmd="$ssh_cmd $SSH_USER@$server"
    else
        ssh_cmd="$ssh_cmd $server"
    fi
    
    # Send SSH command to the target
    tmux send-keys -t "$target" "$ssh_cmd" C-m

    # Handle user switching and initial working directory
    if [ -n "$REMOTE_USER" ]; then
        tmux send-keys -t "$target" "sudo su $REMOTE_USER" C-m
        # Determine directory after switching user
        if [ -n "$INITIAL_WORKDIR" ]; then
            # Use specified workdir (quote path for safety)
            tmux send-keys -t "$target" "cd \"$INITIAL_WORKDIR\"" C-m
        else
            # Default to remote user's home if no specific workdir provided
            tmux send-keys -t "$target" "cd ~" C-m
        fi
    else
        # No remote user switch
        # Change directory if initial workdir is specified
        if [ -n "$INITIAL_WORKDIR" ]; then
            # Use specified workdir (quote path for safety)
            tmux send-keys -t "$target" "cd \"$INITIAL_WORKDIR\"" C-m
        fi
        # If neither REMOTE_USER nor INITIAL_WORKDIR is set, do nothing extra (stay in default SSH login dir)
    fi

    # Normal mode - run the tmux command after potential user switch and cd
    tmux send-keys -t "$target" "$remote_cmd" C-m
    
    # Determine which command to use (if any)
    command_to_send=""
    if [ "$USE_SERVER_COMMAND" = true ] && [ -n "$server_command" ]; then
        # Use server-specific command from servers.conf
        command_to_send="$server_command"
    elif [ -n "$SEND_KEYS_COMMAND" ]; then
        # Use global command specified with send-keys or exec
        command_to_send="$SEND_KEYS_COMMAND"
    fi
    
    # Send the command if one was determined
    if [ -n "$command_to_send" ]; then
        tmux send-keys -t "$target" "$command_to_send"
        # Add ENTER if in execute mode
        if [ "$EXECUTE_COMMAND" = true ]; then
            tmux send-keys -t "$target" C-m
        fi
    fi
done

# Enable synchronize-panes if the flag was set AND layout is pane
if [[ "$SYNCHRONIZE_PANES" = true && "$LAYOUT_MODE" = "pane" ]]; then
    echo "Enabling pane synchronization."
    tmux set-window-option -t $LOCAL_SESSION_NAME:0 synchronize-panes on
fi

# Add key binding to toggle synchronize-panes (only in pane mode)
if [ "$LAYOUT_MODE" = "pane" ]; then
    echo "Adding key binding (Prefix+S) to toggle pane synchronization."
    # Bind 'S' to run a shell command that toggles sync and displays status
    tmux bind S run-shell "tmux set-window-option synchronize-panes && tmux display-message -d 2000 'Synchronize Panes: #{?synchronize-panes,off,on}'"
fi

# Add key binding to toggle layout (works in either mode)
# Use $0 which should be the path to the script, but might need adjustment
# Pass the current session name to the script
echo "Adding key binding (Prefix+L) to toggle layout."
# Using #{pane_current_path} might be more robust if script is run via ./multi-ssh
# Let's try constructing the command carefully. Need the script's absolute path ideally.
# A simpler approach might be to assume 'multi-ssh' is in PATH or use a fixed path if known.
# Let's try using $0 directly first, it often works in run-shell.
# Ensure LOCAL_SESSION_NAME is correctly expanded *when the binding is set*.
tmux bind L run-shell "$0 toggle-layout --local-session $LOCAL_SESSION_NAME"

# Attach to the local tmux session
tmux attach-session -t $LOCAL_SESSION_NAME