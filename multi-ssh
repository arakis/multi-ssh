#!/bin/bash

# This script creates a local tmux session and connects to remote servers from a config file.
# For each server, it establishes an SSH connection and creates or attaches to a remote tmux session.
# If the script is run multiple times, it destroys any existing local session and creates a new one.

# Function to display help message
display_help() {
    echo "Usage: multi-ssh [OPTIONS]"
    echo
    echo "Creates a local tmux session and connects to remote servers listed in the config file."
    echo "For each server, it establishes an SSH connection and creates or attaches to a tmux session."
    echo
    echo "Options:"
    echo "  --help                     Displays this help message and exits"
    echo "  completion                 Returns the completion source file"
    echo
    echo "  Main Commands:"
    echo "  send-keys [command]        Sends keys to each remote session without executing"
    echo "  exec [command]             Executes the specified command on each remote session"
    echo "  kill                       Kill remote tmux sessions and exit"
    echo "  copy [remote:|]:path [remote:|]:path   Copy files between local and remote using rsync"
    echo
    echo "  Session Options:"
    echo "  --syncronize-panes         Create a single window with multiple synchronized panes (one per server)"
    echo "  --local-session <name>     Specify local tmux session name (default: multi-ssh)"
    echo "  --remote-session <name>    Specify remote tmux session name (default: remote-session)"
    echo
    echo "  Connection Options:"
    echo "  --remote-user <username>   Switch to this user after connecting"
    echo "  --ssh-user <username>      SSH login username"
    echo "  --ssh-key <keyfile>        Path to private key file for SSH"
    echo "  --config <path>            Path to servers configuration file (default: ./servers.conf)"
    echo "  --servers <host1,...>      Comma-separated list of servers to use (filters servers.conf)"
    echo
    echo "If no command is specified with send-keys or exec, commands from the config file's [servers] section will be used."
    echo
    echo "Configuration file format (e.g., servers.conf):"
    echo "  [servers]"
    echo "  # List servers, one per line. Optionally add a default command."
    echo "  server1.example.com"
    echo "  server2.example.com ls -la /var/log"
    echo "  192.168.1.10 htop"
    echo
    echo "  [options]"
    echo "  # Set default options (command-line flags override these)"
    echo "  # Options correspond to long command-line flags without '--'"
    echo "  # Example:"
    echo "  # local-session = my-session"
    echo "  # remote-session = remote-tmux"
    echo "  # remote-user = appuser"
    echo "  # ssh-user = admin"
    echo "  # ssh-key = ~/.ssh/id_rsa_admin"
    echo "  # synchronize-panes = true"
    echo
    echo "  Lines starting with # or ; are treated as comments and ignored."
    echo "  Empty lines are also ignored."
    echo
    echo "Examples:"
    echo "  multi-ssh                                   # Connect to all servers using servers.conf"
    echo "  multi-ssh --config ~/my-servers.ini         # Use a custom servers configuration file"
    echo "  multi-ssh --syncronize-panes                # Connect with synchronized panes"
    echo "  multi-ssh exec 'ls -la'                   # Connect and run 'ls -la' on all servers"
    echo "  multi-ssh kill                            # Kill all remote tmux sessions"
    echo "  multi-ssh copy ~/file.txt remote:~/file.txt  # Upload file to all servers"
    echo "  multi-ssh copy remote:/var/log/app.log ./logs/  # Download file from all servers"
    exit 0
}

# Default session names
LOCAL_SESSION_NAME="multi-ssh"
REMOTE_SESSION_NAME="remote-session"

# Default remote user to switch to after connecting
REMOTE_USER=""

# Default SSH connection options
SSH_USER=""
SSH_KEY=""

# Default config file path
CONFIG_FILE="./servers.conf"

# Default options
SYNCHRONIZE_PANES=false
SEND_KEYS_COMMAND=""
USE_SERVER_COMMAND=false
EXECUTE_COMMAND=false
KILL_MODE=false  # New option for killing remote sessions
COPY_MODE=false  # New option for file copying
SRC_PATH=""
DEST_PATH=""
FILTER_SERVERS_LIST="" # New variable for --servers option

# Arrays to hold server addresses and their specific commands
declare -a servers=()
declare -a server_commands=()
# Temporary arrays to store initial config data before filtering
declare -a config_servers=()
declare -a config_server_commands=()

# Function to parse INI configuration file
parse_ini_config() {
    local config_file="$1"
    if [[ ! -f "$config_file" ]]; then
        echo "Warning: Config file '$config_file' not found." >&2
        return 1
    fi

    # Start assuming the implicit [servers] section
    local current_section="servers"
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Trim leading/trailing whitespace
        line=$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

        # Skip empty lines and comments (lines starting with # or ;)
        # Quote the regex pattern to treat '#' and ';' literally
        if [[ -z "$line" || "$line" =~ "^[#;]" ]]; then
            continue
        fi

        # Check for section header
        if [[ "$line" =~ ^\[(.*)\]$ ]]; then
            current_section="${BASH_REMATCH[1]}"
            continue
        fi

        # Process lines based on section
        case "$current_section" in
            servers)
                # Extract server and command
                local server=$(echo "$line" | awk '{print $1}')
                local command=$(echo "$line" | awk '{$1=""; print $0}' | sed 's/^[ \t]*//') # Get rest of line
                if [[ -n "$server" ]]; then
                    # Store in temporary config arrays first
                    config_servers+=("$server")
                    config_server_commands+=("$command")
                fi
                ;;
            options)
                # Process key-value pairs
                if [[ "$line" =~ ^([^=[:space:]]+)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
                    local key="${BASH_REMATCH[1]}"
                    local value="${BASH_REMATCH[2]}"
                    # Trim potential quotes from value
                    value=$(echo "$value" | sed -e "s/^'//" -e "s/'$//" -e 's/^"//' -e 's/"$//')

                    # Set global variables based on key (these might be overridden by CLI args later)
                    case "$key" in
                        local-session) LOCAL_SESSION_NAME="$value" ;;
                        remote-session) REMOTE_SESSION_NAME="$value" ;;
                        remote-user) REMOTE_USER="$value" ;;
                        ssh-user) SSH_USER="$value" ;;
                        ssh-key) SSH_KEY="$value" ;;
                        synchronize-panes)
                            if [[ "$value" == "true" || "$value" == "yes" || "$value" == "1" ]]; then
                                SYNCHRONIZE_PANES=true
                            elif [[ "$value" == "false" || "$value" == "no" || "$value" == "0" ]]; then
                                SYNCHRONIZE_PANES=false
                            else
                                echo "Warning: Invalid boolean value '$value' for synchronize-panes in config file. Ignoring." >&2
                            fi
                            ;;
                        *) echo "Warning: Unknown option '$key' in [options] section of config file." >&2 ;;
                    esac
                else
                     echo "Warning: Malformed line in [options] section: '$line'" >&2
                fi
                ;;
        esac
    done < "$config_file"

    return 0
}

# Handle the completion option
if [[ "$1" == "completion" ]]; then
    # Return the path to the completion file
    echo "$(dirname "$0")/multi-ssh-completion.bash"
    exit 0
fi

# Display help if requested
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    display_help
fi

# Determine config file path *before* parsing other arguments
# This allows --config to be processed correctly if it appears early
temp_config_file="$CONFIG_FILE" # Use default initially
i=1
args=("$@")
while [[ $i -le $# ]]; do
    if [[ "${args[$((i-1))]}" == "--config" && -n "${args[$i]}" ]]; then
        temp_config_file="${args[$i]}"
        # Remove --config and its value from args for later parsing
        unset args[$((i-1))]
        unset args[$i]
        args=("${args[@]}") # Re-index array
        set -- "${args[@]}" # Reset positional parameters
        break # Found config, stop searching
    fi
    ((i++))
done
CONFIG_FILE="$temp_config_file"

# Parse the INI configuration file *first*
# Settings here act as new defaults, potentially overridden by CLI args
parse_ini_config "$CONFIG_FILE"

# Parse command line arguments (these override config file settings)
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            # Already handled, but keep for completeness or if order changes
            display_help
            ;;
        --syncronize-panes)
            SYNCHRONIZE_PANES=true # CLI overrides config
            shift
            ;;
        kill)
            KILL_MODE=true
            shift
            ;;
        copy)
            COPY_MODE=true
            if [[ -n "$2" && -n "$3" && ! "$2" =~ ^--* && ! "$3" =~ ^--* ]]; then
                SRC_PATH="$2"
                DEST_PATH="$3"
                shift 3
            else
                echo "Error: copy requires both source and destination path arguments"
                echo "Usage: copy [remote:|]:source_path [remote:|]:destination_path"
                exit 1
            fi
            ;;
        send-keys|exec)
            if [[ "$1" == "exec" ]]; then
                EXECUTE_COMMAND=true
            fi
            # Check if the next argument is a command and not another option
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SEND_KEYS_COMMAND="$2" # CLI overrides config/default behavior
                USE_SERVER_COMMAND=false # Explicit command given, don't use server-specific ones
                shift 2
            else
                # No command provided with send-keys/exec, use server-specific ones from config
                USE_SERVER_COMMAND=true
                shift 1
            fi
            ;;
        --local-session)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                LOCAL_SESSION_NAME="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --local-session requires a name argument" >&2
                exit 1
            fi
            ;;
        --remote-session)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                REMOTE_SESSION_NAME="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --remote-session requires a name argument" >&2
                exit 1
            fi
            ;;
        --remote-user)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                REMOTE_USER="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --remote-user requires a username argument" >&2
                exit 1
            fi
            ;;
        --ssh-user)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SSH_USER="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --ssh-user requires a username argument" >&2
                exit 1
            fi
            ;;
        --ssh-key)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SSH_KEY="$2" # CLI overrides config
                shift 2
            else
                echo "Error: --ssh-key requires a keyfile path argument" >&2
                exit 1
            fi
            ;;
        --config)
            # Already handled, just shift past the value if it remained somehow
             if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                shift 2
             else
                # Should have been handled, but error if value missing
                echo "Error: --config requires a path argument" >&2
                exit 1
             fi
            ;;
        --servers)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                FILTER_SERVERS_LIST="$2" # Store the comma-separated list
                shift 2
            else
                echo "Error: --servers requires a comma-separated list of servers" >&2
                exit 1
            fi
            ;;
        *)
            # If it's not a known option or command, it might be an implicit command for send-keys/exec
            # Or just an error. Let's assume error for now unless send-keys/exec was the *last* arg.
            # This part is tricky. The current logic handles send-keys/exec [cmd] correctly.
            # If we reach here, it's likely an unknown option.
            echo "Error: Unknown option or misplaced argument: $1" >&2
            display_help # Show help on error
            ;;
    esac
done

# --- Filter servers based on --servers option ---
if [[ -n "$FILTER_SERVERS_LIST" ]]; then
    echo "Filtering servers based on --servers option: $FILTER_SERVERS_LIST"
    declare -a requested_servers=()
    # Split the comma-separated list into an array
    IFS=',' read -ra requested_servers <<< "$FILTER_SERVERS_LIST"

    # Create a map for quick lookup of config servers and their commands
    declare -A config_server_map
    for i in "${!config_servers[@]}"; do
        config_server_map["${config_servers[$i]}"]="${config_server_commands[$i]}"
    done

    # Clear the final server arrays and rebuild based on the requested list
    servers=()
    server_commands=()

    for req_server in "${requested_servers[@]}"; do
        # Trim whitespace just in case
        req_server=$(echo "$req_server" | xargs)
        if [[ -v config_server_map["$req_server"] ]]; then
            # Server found in config, use it and its command
            servers+=("$req_server")
            server_commands+=("${config_server_map["$req_server"]}")
            echo "  -> Including '$req_server' (found in config)"
        else
            # Server not found in config, include it without a command
            servers+=("$req_server")
            server_commands+=("")
            echo "  -> Including '$req_server' (not found in config)"
        fi
    done
else
    # No --servers filter, use all servers from the config file
    servers=("${config_servers[@]}")
    server_commands=("${config_server_commands[@]}")
fi
# --- End server filtering ---

# Check if servers array is empty (config file not found or empty [servers] section, or filter resulted in empty list)
if [ ${#servers[@]} -eq 0 ]; then
    # Adjust error message slightly to account for filtering
    if [[ -n "$FILTER_SERVERS_LIST" ]]; then
        echo "Error: No servers matched the filter criteria from '$CONFIG_FILE'." >&2
    elif [ ! -f "$CONFIG_FILE" ]; then
         echo "Error: Configuration file '$CONFIG_FILE' not found." >&2
    else
         echo "Error: No servers defined in the [servers] section of '$CONFIG_FILE'." >&2
    fi
    # Allow kill and copy modes to proceed even if the list is empty now,
    # they might have specific logic or warnings later.
    if [ "$COPY_MODE" = false ] && [ "$KILL_MODE" = false ]; then
        exit 1
    fi
fi

# Helper functions for copy mode (and now kill mode)
setup_ssh_options() {
    local ssh_opts="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
    if [ -n "$SSH_KEY" ]; then
        ssh_opts="$ssh_opts -i $SSH_KEY"
    fi
    echo "$ssh_opts"
}

get_server_address() {
    local server="$1"
    local server_addr="$server"
    if [ -n "$SSH_USER" ]; then
        server_addr="$SSH_USER@$server"
    fi
    echo "$server_addr"
}

# New function to handle killing remote sessions directly
kill_remote_sessions() {
    echo "Attempting to kill remote tmux session '$REMOTE_SESSION_NAME' on all servers..."

    for i in $(seq 0 $((${#servers[@]}-1))); do
        local server=${servers[$i]}
        local ssh_opts=$(setup_ssh_options)
        local server_addr=$(get_server_address "$server")

        # Construct the remote command
        local kill_cmd="tmux kill-session -t $REMOTE_SESSION_NAME"
        if [ -n "$REMOTE_USER" ]; then
            # If remote user is specified, run the kill command as that user via sudo
            # Ensure sudo doesn't require a tty (-n) and runs in the background briefly (-b) if needed,
            # though for kill-session, direct execution should be fine.
            # Using direct command execution is generally preferred over complex sudo options.
            kill_cmd="sudo -u $REMOTE_USER $kill_cmd"
        fi

        # Add error suppression for cases where the session doesn't exist
        kill_cmd="$kill_cmd 2>/dev/null || true" # Proceed even if kill fails (e.g., session not found)

        echo "Executing on $server: ssh $ssh_opts $server_addr \"$kill_cmd\""

        # Execute the kill command via a non-interactive SSH session
        ssh $ssh_opts $server_addr "$kill_cmd"

        if [ $? -eq 0 ]; then
            # Note: This only checks SSH connection success, not necessarily tmux kill success.
            # The '|| true' in kill_cmd ensures SSH usually exits 0 unless the connection fails.
            echo "Kill command sent to $server."
        else
            echo "Error sending kill command to $server."
        fi
        echo "------------------------"
    done

    echo "Finished sending kill commands to all servers."
    # Optionally, kill the local session if it somehow exists (though it shouldn't be created in kill mode)
    if tmux has-session -t $LOCAL_SESSION_NAME 2>/dev/null; then
        echo "Killing potentially existing local session: $LOCAL_SESSION_NAME"
        tmux kill-session -t $LOCAL_SESSION_NAME
    fi
    exit 0
}

# --- Execute Kill Mode ---
# If in kill mode, execute the dedicated function and exit immediately.
# This happens *before* creating the local session.
if [ "$KILL_MODE" = true ]; then
    # Check server list *after* potential filtering
    if [ ${#servers[@]} -eq 0 ]; then
         echo "Warning: Server list is empty (due to config or filter). Kill command will not be sent."
         exit 1 # Or exit 0 depending on desired behavior
    fi
    kill_remote_sessions # Call the new function
fi

# Destroy existing local session if it exists (prevents errors on re-run)
tmux has-session -t $LOCAL_SESSION_NAME 2>/dev/null
if [ $? -eq 0 ]; then
    echo "Destroying existing local session: $LOCAL_SESSION_NAME"
    tmux kill-session -t $LOCAL_SESSION_NAME
fi

# Check if tmux is installed (skip if only using copy mode)
if [ "$COPY_MODE" = false ] && ! command -v tmux &> /dev/null; then
    echo "Error: tmux is not installed. Please install tmux and try again."
    exit 1
fi

# Check if specified config file exists (This check might be less relevant now if --servers is used without a config)
# Keep it for cases where --servers isn't used or relies on config commands
if [[ -z "$FILTER_SERVERS_LIST" && ! -f "$CONFIG_FILE" ]]; then
    echo "Error: Configuration file '$CONFIG_FILE' not found and --servers not specified."
    exit 1
fi

# Ensure we have servers to work with (redundant with the check after filtering, but safe)
if [ ${#servers[@]} -eq 0 ]; then
    # Allow kill/copy modes to proceed, error for normal mode
    if [ "$COPY_MODE" = false ] && [ "$KILL_MODE" = false ]; then
        echo "Error: No servers to connect to (check config file and --servers filter)."
        exit 1
    fi
fi

# If in copy mode, perform the rsync operations and exit
if [ "$COPY_MODE" = true ]; then
    # Check server list *after* potential filtering
    if [ ${#servers[@]} -eq 0 ]; then
        echo "Warning: Server list is empty (due to config or filter). Copy command will not be executed."
        exit 1 # Or exit 0
    fi
    # Process each server
    for i in $(seq 0 $((${#servers[@]}-1))); do
        server=${servers[$i]}
        ssh_opts=$(setup_ssh_options)
        server_addr=$(get_server_address "$server")
        
        # Determine if we're uploading or downloading
        if [[ "$SRC_PATH" =~ ^remote: ]]; then
            # Downloading: remote to local
            remote_path=$(process_remote_path "${SRC_PATH#remote:}")
            local_path="$DEST_PATH"
            operation="downloading"
            
            # Construct rsync command
            rsync_cmd=$(build_rsync_command "$server_addr:\"$remote_path\"" "$local_path" "$ssh_opts")
            
            # Echo operation info
            echo "Downloading file(s) from $server:$remote_path to $local_path"
            
        else
            # Uploading: local to remote
            local_path="$SRC_PATH"
            remote_path=$(process_remote_path "${DEST_PATH#remote:}")
            operation="uploading"
            
            # Construct rsync command
            rsync_cmd=$(build_rsync_command "$local_path" "$server_addr:\"$remote_path\"" "$ssh_opts")
            
            # Echo operation info
            echo "Uploading file(s) from $local_path to $server:$remote_path"
        fi
        
        # Execute the rsync command
        eval $rsync_cmd
        
        # Check for success
        if [ $? -eq 0 ]; then
            echo "Successfully ${operation} file(s) for server $server"
        else
            echo "Error ${operation} file(s) for server $server"
        fi
        
        echo "------------------------"
    done
    
    # Exit after completing all copy operations
    exit 0
fi

# Create a new local tmux session
tmux new-session -d -s $LOCAL_SESSION_NAME

# Define the remote command to check for existing session and create or attach
remote_cmd="if tmux has-session -t $REMOTE_SESSION_NAME 2>/dev/null; then tmux attach-session -t $REMOTE_SESSION_NAME; else tmux new-session -s $REMOTE_SESSION_NAME; fi"

# Process all servers
for i in $(seq 0 $((${#servers[@]}-1))); do
    server=${servers[$i]}
    server_command=${server_commands[$i]}
    
    if [ $i -eq 0 ]; then
        # For the first server, rename the initial window
        tmux rename-window -t $LOCAL_SESSION_NAME:0 "$server"
    else
        if [ "$SYNCHRONIZE_PANES" = true ]; then
            # Create a new pane for each additional server when sync is enabled
            tmux split-window -t $LOCAL_SESSION_NAME:0 -v
            # Ensure even layout for all panes
            tmux select-layout -t $LOCAL_SESSION_NAME:0 tiled
        else
            # Create a new window for each additional server (original behavior)
            tmux new-window -t $LOCAL_SESSION_NAME: -n "$server"
        fi
    fi
    
    # Determine target for send-keys
    if [ "$SYNCHRONIZE_PANES" = true ]; then
        # When using panes, we need to target the specific pane
        target="$LOCAL_SESSION_NAME:0.$i"
    else
        # When using windows, we target the window
        target="$LOCAL_SESSION_NAME:$i"
    fi
    
    # Disable shell history in the local pane
    tmux send-keys -t "$target" "unset HISTFILE" C-m

    # Build SSH command with optional parameters
    ssh_cmd="ssh -t -o StrictHostKeyChecking=no"
    if [ -n "$SSH_KEY" ]; then
        ssh_cmd="$ssh_cmd -i $SSH_KEY"
    fi
    if [ -n "$SSH_USER" ]; then
        ssh_cmd="$ssh_cmd $SSH_USER@$server"
    else
        ssh_cmd="$ssh_cmd $server"
    fi
    
    # Send SSH command to the target
    tmux send-keys -t "$target" "$ssh_cmd" C-m

    # if remote user is set, send sudo su $REMOTE_USER before running tmux
    if [ -n "$REMOTE_USER" ]; then
        tmux send-keys -t "$target" "sudo su $REMOTE_USER" C-m
        tmux send-keys -t "$target" "cd ~" C-m
    fi
    
    # Normal mode - run the tmux command after potential user switch
    tmux send-keys -t "$target" "$remote_cmd" C-m
    
    # Determine which command to use (if any)
    command_to_send=""
    if [ "$USE_SERVER_COMMAND" = true ] && [ -n "$server_command" ]; then
        # Use server-specific command from servers.conf
        command_to_send="$server_command"
    elif [ -n "$SEND_KEYS_COMMAND" ]; then
        # Use global command specified with send-keys or exec
        command_to_send="$SEND_KEYS_COMMAND"
    fi
    
    # Send the command if one was determined
    if [ -n "$command_to_send" ]; then
        tmux send-keys -t "$target" "$command_to_send"
        # Add ENTER if in execute mode
        if [ "$EXECUTE_COMMAND" = true ]; then
            tmux send-keys -t "$target" C-m
        fi
    fi
done

# Enable synchronize-panes if the flag was set
if [ "$SYNCHRONIZE_PANES" = true ]; then
    tmux set-window-option -t $LOCAL_SESSION_NAME:0 synchronize-panes on
fi

# Attach to the local tmux session
tmux attach-session -t $LOCAL_SESSION_NAME

process_remote_path() {
    local path="$1"
    # If remote user is specified, replace ~ with /home/username in remote path
    if [ -n "$REMOTE_USER" ]; then
        # Replace any occurrence of ~/ with the remote user's home directory
        path="${path//\~\//\/home\/$REMOTE_USER\/}"
        # Also handle standalone ~ (without trailing slash)
        path="${path//\~/\/home\/$REMOTE_USER}"
    fi
    echo "$path"
}

build_rsync_command() {
    local src="$1"
    local dest="$2"
    local ssh_opts="$3"
    
    local rsync_cmd="rsync -avz -e 'ssh $ssh_opts'"
    
    # Add remote user sudo if specified
    if [ -n "$REMOTE_USER" ]; then
        rsync_cmd="$rsync_cmd --rsync-path=\"sudo -u $REMOTE_USER rsync\""
    fi
    
    # Complete the command with source and destination
    rsync_cmd="$rsync_cmd \"$src\" \"$dest\""
    
    echo "$rsync_cmd"
}