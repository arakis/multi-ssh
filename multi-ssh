#!/bin/bash

# This script creates a local tmux session and connects to remote servers from servers.conf.
# For each server, it establishes an SSH connection and creates or attaches to a remote tmux session.
# If the script is run multiple times, it destroys any existing local session and creates a new one.

# Function to display help message
display_help() {
    echo "Usage: multi-ssh [OPTIONS]"
    echo
    echo "Creates a local tmux session and connects to remote servers listed in servers.conf."
    echo "For each server, it establishes an SSH connection and creates or attaches to a tmux session."
    echo
    echo "Options:"
    echo "  --help                     Display this help message and exit"
    echo "  --completion               Return the path to the completion file"
    echo "  --syncronize-panes         Create a single window with multiple synchronized panes (one per server)"
    echo "  --send-keys [command]      Send keys to each remote session without executing"
    echo "  --exec [command]           Execute the specified command on each remote session"
    echo "  --kill                     Kill remote tmux sessions and exit"
    echo "  --copy [remote:|]:path [remote:|]:path   Copy files between local and remote using rsync"
    echo "  --local-session <name>     Specify local tmux session name (default: multi-ssh)"
    echo "  --remote-session <name>    Specify remote tmux session name (default: remote-session)"
    echo "  --remote-user <username>   Switch to this user after connecting"
    echo "  --ssh-user <username>      SSH login username"
    echo "  --ssh-key <keyfile>        Path to private key file for SSH"
    echo "  --config <path>            Path to servers configuration file (default: ./servers.conf)"
    echo
    echo "If no command is specified with --send-keys or --exec, commands from servers.conf will be used."
    echo
    echo "Configuration file format (servers.conf):"
    echo "  Each line should contain a server address/hostname, optionally followed by a command."
    echo "  Format: <server> [command]"
    echo "  Examples:"
    echo "    server1.example.com"
    echo "    server2.example.com ls -la /var/log"
    echo "    192.168.1.10 htop"
    echo "  Lines starting with # are treated as comments and ignored."
    echo "  Empty lines are also ignored."
    echo
    echo "Examples:"
    echo "  multi-ssh                                   # Connect to all servers"
    echo "  multi-ssh --syncronize-panes                # Connect with synchronized panes"
    echo "  multi-ssh --exec 'ls -la'                   # Connect and run 'ls -la' on all servers"
    echo "  multi-ssh --kill                            # Kill all remote tmux sessions"
    echo "  multi-ssh --config ~/my-servers.conf        # Use a custom servers configuration file"
    echo "  multi-ssh --copy ~/file.txt remote:~/file.txt  # Upload file to all servers"
    echo "  multi-ssh --copy remote:/var/log/app.log ./logs/  # Download file from all servers"
    exit 0
}

# Default session names
LOCAL_SESSION_NAME="multi-ssh"
REMOTE_SESSION_NAME="remote-session"

# Default remote user to switch to after connecting
REMOTE_USER=""

# Default SSH connection options
SSH_USER=""
SSH_KEY=""

# Default config file path
CONFIG_FILE="servers.conf"

# Default options
SYNCHRONIZE_PANES=false
SEND_KEYS_COMMAND=""
USE_SERVER_COMMAND=false
EXECUTE_COMMAND=false
KILL_MODE=false  # New option for killing remote sessions
COPY_MODE=false  # New option for file copying
SRC_PATH=""
DEST_PATH=""

# Handle the completion option
if [[ "$1" == "--completion" ]]; then
    # Return the path to the completion file
    echo "$(dirname "$0")/multi-ssh-completion.bash"
    exit 0
fi

# Display help if requested
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    display_help
fi

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            display_help
            ;;
        --syncronize-panes)
            SYNCHRONIZE_PANES=true
            shift
            ;;
        --kill)
            KILL_MODE=true
            shift
            ;;
        --copy)
            COPY_MODE=true
            if [[ -n "$2" && -n "$3" && ! "$2" =~ ^--* && ! "$3" =~ ^--* ]]; then
                SRC_PATH="$2"
                DEST_PATH="$3"
                shift 3
            else
                echo "Error: --copy requires both source and destination path arguments"
                echo "Usage: --copy [remote:|]:source_path [remote:|]:destination_path"
                exit 1
            fi
            ;;
        --send-keys|--exec)
            if [[ "$1" == "--exec" ]]; then
                EXECUTE_COMMAND=true
            fi
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SEND_KEYS_COMMAND="$2"
                shift 2
            else
                # No argument provided, use commands from servers.conf
                USE_SERVER_COMMAND=true
                shift
            fi
            ;;
        --local-session)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                LOCAL_SESSION_NAME="$2"
                shift 2
            else
                echo "Error: --local-session requires a name argument"
                exit 1
            fi
            ;;
        --remote-session)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                REMOTE_SESSION_NAME="$2"
                shift 2
            else
                echo "Error: --remote-session requires a name argument"
                exit 1
            fi
            ;;
        --remote-user)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                REMOTE_USER="$2"
                shift 2
            else
                echo "Error: --remote-user requires a username argument"
                exit 1
            fi
            ;;
        --ssh-user)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SSH_USER="$2"
                shift 2
            else
                echo "Error: --ssh-user requires a username argument"
                exit 1
            fi
            ;;
        --ssh-key)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                SSH_KEY="$2"
                shift 2
            else
                echo "Error: --ssh-key requires a path to key file"
                exit 1
            fi
            ;;
        --config)
            if [[ -n "$2" && ! "$2" =~ ^--* ]]; then
                CONFIG_FILE="$2"
                shift 2
            else
                echo "Error: --config requires a path to configuration file"
                exit 1
            fi
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help to display available options"
            exit 1
            ;;
    esac
done

# Validate flag combinations
if [ "$SYNCHRONIZE_PANES" = true ] && ([ -n "$SEND_KEYS_COMMAND" ] || [ "$USE_SERVER_COMMAND" = true ] || [ "$EXECUTE_COMMAND" = true ]); then
    echo "Error: --syncronize-panes cannot be used together with --send-keys or --exec"
    echo "Please use either --syncronize-panes or --send-keys/--exec, but not both"
    exit 1
fi

# Check that kill mode is not used with synchronized panes
if [ "$SYNCHRONIZE_PANES" = true ] && [ "$KILL_MODE" = true ]; then
    echo "Error: --syncronize-panes cannot be used together with --kill"
    echo "Please use either --syncronize-panes or --kill, but not both"
    exit 1
fi

# Validate copy mode arguments
if [ "$COPY_MODE" = true ]; then
    # Check if at least one path has the remote: prefix
    if [[ ! "$SRC_PATH" =~ ^remote: && ! "$DEST_PATH" =~ ^remote: ]]; then
        echo "Error: At least one path must have the 'remote:' prefix in copy mode"
        echo "Usage: --copy [remote:|]:source_path [remote:|]:destination_path"
        exit 1
    fi
    
    # Check for incompatible flags
    if [ "$SYNCHRONIZE_PANES" = true ] || [ "$KILL_MODE" = true ] || [ -n "$SEND_KEYS_COMMAND" ] || [ "$USE_SERVER_COMMAND" = true ] || [ "$EXECUTE_COMMAND" = true ]; then
        echo "Error: --copy cannot be used with other operational flags"
        echo "Please use only --copy with its arguments"
        exit 1
    fi
    
    # Ensure rsync is installed
    if ! command -v rsync &> /dev/null; then
        echo "Error: rsync is not installed. Please install rsync and try again."
        exit 1
    fi
fi

# Check if tmux is installed (skip if only using copy mode)
if [ "$COPY_MODE" = false ] && ! command -v tmux &> /dev/null; then
    echo "Error: tmux is not installed. Please install tmux and try again."
    exit 1
fi

# Check if the local tmux session already exists (skip if only using copy mode)
if [ "$COPY_MODE" = false ] && tmux has-session -t $LOCAL_SESSION_NAME 2>/dev/null; then
    # Kill existing session
    tmux kill-session -t $LOCAL_SESSION_NAME
fi

# Check if specified config file exists
if [ ! -f "$CONFIG_FILE" ]; then
    echo "Error: Configuration file '$CONFIG_FILE' not found."
    exit 1
fi

# Load servers from the config file
servers=()
server_commands=()
while IFS= read -r line; do
    # Skip empty lines and comments (lines starting with #)
    if [ -n "$line" ] && [[ ! "$line" =~ ^[[:space:]]*# ]]; then
        # Split the line by the first space character
        server=$(echo "$line" | cut -d' ' -f1)
        # Get the rest of the line as the command (if any)
        command=$(echo "$line" | cut -s -d' ' -f2-)
        
        servers+=("$server")
        server_commands+=("$command")
    fi
done < "$CONFIG_FILE"

# Ensure config file has at least one server
if [ ${#servers[@]} -eq 0 ]; then
    echo "No servers found in '$CONFIG_FILE'"
    exit 1
fi

# If in copy mode, perform the rsync operations and exit
if [ "$COPY_MODE" = true ]; then
    # Process each server
    for i in $(seq 0 $((${#servers[@]}-1))); do
        server=${servers[$i]}
        
        # Determine if we're uploading or downloading
        if [[ "$SRC_PATH" =~ ^remote: ]]; then
            # Downloading: remote to local
            remote_path="${SRC_PATH#remote:}"
            local_path="$DEST_PATH"
            operation="downloading"
            
            # If remote user is specified, replace ~ with /home/username in remote path
            if [ -n "$REMOTE_USER" ]; then
                # Replace any occurrence of ~/ with the remote user's home directory
                remote_path="${remote_path//\~\//\/home\/$REMOTE_USER\/}"
                # Also handle standalone ~ (without trailing slash)
                remote_path="${remote_path//\~/\/home\/$REMOTE_USER}"
            fi
            
            # Construct the SSH command parts
            ssh_opts=""
            if [ -n "$SSH_KEY" ]; then
                ssh_opts="$ssh_opts -i $SSH_KEY"
            fi
            
            # Construct server address with optional SSH user
            server_addr="$server"
            if [ -n "$SSH_USER" ]; then
                server_addr="$SSH_USER@$server"
            fi
            
            # Construct rsync command with appropriate options
            rsync_cmd="rsync -avz"
            
            # Add SSH options
            rsync_cmd="$rsync_cmd -e \"ssh $ssh_opts\""
            
            # Add remote user sudo if specified
            if [ -n "$REMOTE_USER" ]; then
                rsync_cmd="$rsync_cmd --rsync-path=\"sudo -u $REMOTE_USER rsync\""
            fi
            
            # Complete the command with source and destination
            rsync_cmd="$rsync_cmd $server_addr:\"$remote_path\" \"$local_path\""
            
            # Echo operation info
            echo "Downloading file(s) from $server:$remote_path to $local_path"
            
        else
            # Uploading: local to remote
            local_path="$SRC_PATH"
            remote_path="${DEST_PATH#remote:}"
            operation="uploading"
            
            # If remote user is specified, replace ~ with /home/username in remote path
            if [ -n "$REMOTE_USER" ]; then
                # Replace any occurrence of ~/ with the remote user's home directory
                remote_path="${remote_path//\~\//\/home\/$REMOTE_USER\/}"
                # Also handle standalone ~ (without trailing slash)
                remote_path="${remote_path//\~/\/home\/$REMOTE_USER}"
            fi
            
            # Construct the SSH command parts
            ssh_opts=""
            if [ -n "$SSH_KEY" ]; then
                ssh_opts="$ssh_opts -i $SSH_KEY"
            fi
            
            # Construct server address with optional SSH user
            server_addr="$server"
            if [ -n "$SSH_USER" ]; then
                server_addr="$SSH_USER@$server"
            fi
            
            # Construct rsync command with appropriate options
            rsync_cmd="rsync -avz"
            
            # Add SSH options
            rsync_cmd="$rsync_cmd -e \"ssh $ssh_opts\""
            
            # Add remote user sudo if specified
            if [ -n "$REMOTE_USER" ]; then
                rsync_cmd="$rsync_cmd --rsync-path=\"sudo -u $REMOTE_USER rsync\""
            fi
            
            # Complete the command with source and destination
            rsync_cmd="$rsync_cmd \"$local_path\" $server_addr:\"$remote_path\""
            
            # Echo operation info
            echo "Uploading file(s) from $local_path to $server:$remote_path"
        fi
        
        # Execute the rsync command
        eval $rsync_cmd
        
        # Check for success
        if [ $? -eq 0 ]; then
            echo "Successfully ${operation} file(s) for server $server"
        else
            echo "Error ${operation} file(s) for server $server"
        fi
        
        echo "------------------------"
    done
    
    # Exit after completing all copy operations
    exit 0
fi

# Create a new local tmux session
tmux new-session -d -s $LOCAL_SESSION_NAME

# Define the remote command to check for existing session and create or attach
remote_cmd="if tmux has-session -t $REMOTE_SESSION_NAME 2>/dev/null; then tmux attach-session -t $REMOTE_SESSION_NAME; else tmux new-session -s $REMOTE_SESSION_NAME; fi"

# Process all servers
for i in $(seq 0 $((${#servers[@]}-1))); do
    server=${servers[$i]}
    server_command=${server_commands[$i]}
    
    if [ $i -eq 0 ]; then
        # For the first server, rename the initial window
        tmux rename-window -t $LOCAL_SESSION_NAME:0 "$server"
    else
        if [ "$SYNCHRONIZE_PANES" = true ]; then
            # Create a new pane for each additional server when sync is enabled
            tmux split-window -t $LOCAL_SESSION_NAME:0 -v
            # Ensure even layout for all panes
            tmux select-layout -t $LOCAL_SESSION_NAME:0 tiled
        else
            # Create a new window for each additional server (original behavior)
            tmux new-window -t $LOCAL_SESSION_NAME: -n "$server"
        fi
    fi
    
    # Determine target for send-keys
    if [ "$SYNCHRONIZE_PANES" = true ]; then
        # When using panes, we need to target the specific pane
        target="$LOCAL_SESSION_NAME:0.$i"
    else
        # When using windows, we target the window
        target="$LOCAL_SESSION_NAME:$i"
    fi
    
    # Disable shell history in the local pane
    tmux send-keys -t "$target" "set +o history" C-m

    # Build SSH command with optional parameters
    ssh_cmd="ssh -t"
    if [ -n "$SSH_KEY" ]; then
        ssh_cmd="$ssh_cmd -i $SSH_KEY"
    fi
    if [ -n "$SSH_USER" ]; then
        ssh_cmd="$ssh_cmd $SSH_USER@$server"
    else
        ssh_cmd="$ssh_cmd $server"
    fi
    
    # Send SSH command to the target
    tmux send-keys -t "$target" "$ssh_cmd" C-m

    # if remote user is set, send sudo su $REMOTE_USER before running tmux
    if [ -n "$REMOTE_USER" ]; then
        tmux send-keys -t "$target" "sudo su $REMOTE_USER" C-m
        tmux send-keys -t "$target" "cd ~" C-m
    fi
    
    if [ "$KILL_MODE" = true ]; then
        # Kill the remote tmux session
        tmux send-keys -t "$target" "tmux kill-session -t $REMOTE_SESSION_NAME 2>/dev/null || echo 'No remote session to kill'" C-m
    else
        # Normal mode - run the tmux command after potential user switch
        tmux send-keys -t "$target" "$remote_cmd" C-m
        
        # Determine which command to use (if any)
        command_to_send=""
        if [ "$USE_SERVER_COMMAND" = true ] && [ -n "$server_command" ]; then
            # Use server-specific command from servers.conf
            command_to_send="$server_command"
        elif [ -n "$SEND_KEYS_COMMAND" ]; then
            # Use global command specified with --send-keys or --exec
            command_to_send="$SEND_KEYS_COMMAND"
        fi
        
        # Send the command if one was determined
        if [ -n "$command_to_send" ]; then
            tmux send-keys -t "$target" "$command_to_send"
            # Add ENTER if in execute mode
            if [ "$EXECUTE_COMMAND" = true ]; then
                tmux send-keys -t "$target" C-m
            fi
        fi
    fi
done

# Enable synchronize-panes if the flag was set
if [ "$SYNCHRONIZE_PANES" = true ]; then
    tmux set-window-option -t $LOCAL_SESSION_NAME:0 synchronize-panes on
fi

# If in kill mode, wait briefly for all commands to complete then kill local session
if [ "$KILL_MODE" = true ]; then
    # Wait a moment for all the exit commands to finish
    sleep 2
    tmux kill-session -t $LOCAL_SESSION_NAME
    echo "All remote and local sessions killed."
    exit 0
fi

# Attach to the local tmux session
tmux attach-session -t $LOCAL_SESSION_NAME